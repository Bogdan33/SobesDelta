# SobesDelta
# Калькулятор выражений на C++

Калькулятор для вычисления математических выражений с поддержкой переменных, функций и различных типов скобок.  
Реализован на C++ с использованием алгоритма обратной польской записи (RPN).

## Особенности

- Бинарные операции: `+`, `-`, `*`, `/`, `^` (степень)
- Унарные функции: `sin`, `cos`, `!` (факториал)
- Константы: `PI` (3.141592653589793)
- Переменные (например, `x`, `y`)
- Поддержка скобок: `()`, `[]`, `{}` с проверкой соответствия типов
- Четкие сообщения об ошибках (синтаксис, неопределенные переменные и т.д.)
- Кроссплатформенность (Linux/Windows)

## Требования

- Компилятор C++17 (GCC, Clang, MSVC)
- CMake 3.12+
- Библиотека [CLI11](https://github.com/CLIUtils/CLI11) (автоматически подключается через CMake)

## Использование
"(2 + x) * 2" --var x=3.14

## Поддерживаемые операции

| Тип операции         | Элементы                          | Приоритет | Ассоциативность  |
|----------------------|-----------------------------------|-----------|------------------|
| **Скобки**           | `()`, `[]`, `{}`                  | Высший    | -                |
| **Функции**          | `sin`, `cos`, `!` (факториал)     | 4         | -                |
| **Возведение в степень** | `^`                          | 4         | Правая           |
| **Умножение/Деление**| `*`, `/`                         | 3         | Левая            |
| **Сложение/Вычитание**| `+`, `-`                        | 2         | Левая            |

### Пояснения:
- Скобки имеют наивысший приоритет и требуют соответствия типов (`{}` с `{}`, `[]` с `]` и т.д.)
- Факториал (`!`) трактуется как постфиксная функция
- Возведение в степень (`^`) выполняется справа налево: `2^3^2 = 2^(3^2) = 512`
- Арифметические операторы вычисляются слева направо: `8/2/2 = (8/2)/2 = 2`

## Добавление новых функций
Чтобы добавить новую функцию (например, tan):

### Лексер (lexer.cpp):
### Обновите метод parse_identifier():
cpp
if (id == "sin" || id == "cos" || id == "!" || id == "tan") {
    tokens.push_back(std::make_unique<FunctionToken>(id));
}

### Вычислитель (evaluator.cpp):
### Добавьте обработку в handleFunction():
cpp
else if (func.getFunctionName() == "tan") {
    calculationStack.push(tan(arg));
}

### Парсер (parser.cpp):
Убедитесь, что функция имеет правильный приоритет в getPriority().
